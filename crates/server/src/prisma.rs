// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
static DATAMODEL_STR : & 'static str = "datasource db {\n    provider = \"sqlite\"\n    url      = \"file:dev.db\"\n}\n\ngenerator client {\n    // Corresponds to the cargo alias created earlier\n    provider = \"cargo prisma\"\n    // The location to generate the schema. Is relative to the position of the schema\n    output   = \"./crates/server/src/prisma.rs\"\n}\n\nmodel User {\n    id       Int    @id @default(autoincrement())\n    username String @unique\n}\n" ;
static DATABASE_STR: &'static str = "sqlite";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	let config = ::prisma_client_rust::datamodel::parse_configuration(DATAMODEL_STR)?.subject;
	let source = config
		.datasources
		.first()
		.expect("Please supply a datasource in your schema.prisma file");
	let url = if let Some(url) = source.load_shadow_database_url()? {
		url
	} else {
		source.load_url(|key| std::env::var(key).ok())?
	};
	let url = if url.starts_with("file:") {
		let path = url.split(":").nth(1).unwrap();
		if std::path::Path::new("./schema.prisma").exists() {
			url
		} else if std::path::Path::new("./prisma/schema.prisma").exists() {
			format!("file:./prisma/{}", path)
		} else {
			url
		}
	} else {
		url
	};
	new_client_with_url(&url).await
}
pub async fn new_client_with_url(
	url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
	let config = ::prisma_client_rust::datamodel::parse_configuration(DATAMODEL_STR)?.subject;
	let source = config
		.datasources
		.first()
		.expect("Please supply a datasource in your schema.prisma file");
	let (db_name, executor) =
		::prisma_client_rust::query_core::executor::load(&source, &[], &url).await?;
	let internal_model =
		::prisma_client_rust::prisma_models::InternalDataModelBuilder::new(DATAMODEL_STR)
			.build(db_name);
	let query_schema = std::sync::Arc::new(prisma_client_rust::query_core::schema_builder::build(
		internal_model,
		true,
		source.capabilities(),
		vec![],
		source.referential_integrity(),
	));
	executor.primary_connector().get_connection().await?;
	Ok(PrismaClient::_new(executor, query_schema))
}
pub mod user {
	use super::_prisma::*;
	use super::*;
	pub mod id {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: i32) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
			UniqueWhereParam::IdEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Id(direction)
		}
		pub fn in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::IdInVec(value)
		}
		pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
			WhereParam::IdNotInVec(value)
		}
		pub fn lt(value: i32) -> WhereParam {
			WhereParam::IdLt(value)
		}
		pub fn lte(value: i32) -> WhereParam {
			WhereParam::IdLte(value)
		}
		pub fn gt(value: i32) -> WhereParam {
			WhereParam::IdGt(value)
		}
		pub fn gte(value: i32) -> WhereParam {
			WhereParam::IdGte(value)
		}
		pub fn not(value: i32) -> WhereParam {
			WhereParam::IdNot(value)
		}
		pub fn increment(value: i32) -> SetParam {
			SetParam::IncrementId(value)
		}
		pub fn decrement(value: i32) -> SetParam {
			SetParam::DecrementId(value)
		}
		pub fn multiply(value: i32) -> SetParam {
			SetParam::MultiplyId(value)
		}
		pub fn divide(value: i32) -> SetParam {
			SetParam::DivideId(value)
		}
		pub struct Set(pub i32);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetId(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Id(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Id(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("id").build()
			}
		}
	}
	pub mod username {
		use super::super::*;
		use super::_prisma::*;
		use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
		pub fn set<T: From<Set>>(value: String) -> T {
			Set(value).into()
		}
		pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
			UniqueWhereParam::UsernameEquals(value).into()
		}
		pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
			OrderByParam::Username(direction)
		}
		pub fn in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::UsernameInVec(value)
		}
		pub fn not_in_vec(value: Vec<String>) -> WhereParam {
			WhereParam::UsernameNotInVec(value)
		}
		pub fn lt(value: String) -> WhereParam {
			WhereParam::UsernameLt(value)
		}
		pub fn lte(value: String) -> WhereParam {
			WhereParam::UsernameLte(value)
		}
		pub fn gt(value: String) -> WhereParam {
			WhereParam::UsernameGt(value)
		}
		pub fn gte(value: String) -> WhereParam {
			WhereParam::UsernameGte(value)
		}
		pub fn contains(value: String) -> WhereParam {
			WhereParam::UsernameContains(value)
		}
		pub fn starts_with(value: String) -> WhereParam {
			WhereParam::UsernameStartsWith(value)
		}
		pub fn ends_with(value: String) -> WhereParam {
			WhereParam::UsernameEndsWith(value)
		}
		pub fn not(value: String) -> WhereParam {
			WhereParam::UsernameNot(value)
		}
		pub struct Set(pub String);
		impl From<Set> for SetParam {
			fn from(value: Set) -> Self {
				Self::SetUsername(value.0)
			}
		}
		pub struct Include;
		impl Into<super::IncludeParam> for Include {
			fn into(self) -> super::IncludeParam {
				super::IncludeParam::Username(self)
			}
		}
		impl Include {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("username").build()
			}
		}
		pub struct Select;
		impl Into<super::SelectParam> for Select {
			fn into(self) -> super::SelectParam {
				super::SelectParam::Username(self)
			}
		}
		impl Select {
			pub fn to_selection(self) -> ::prisma_client_rust::Selection {
				::prisma_client_rust::Selection::builder("username").build()
			}
		}
	}
	pub fn _outputs() -> Vec<::prisma_client_rust::Selection> {
		["id", "username"]
			.into_iter()
			.map(|o| {
				let builder = ::prisma_client_rust::Selection::builder(o);
				builder.build()
			})
			.collect()
	}
	pub fn create(username: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
		(username, _params)
	}
	#[macro_export]
	macro_rules ! _select_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Select { Select ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: user :: select ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Select (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: select :: SelectType for Select { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Select ($ crate :: prisma :: user :: select ! (@ selections_to_select_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect ()) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , username } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { $ (pub $ field : $ crate :: prisma :: user :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (username)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) , ", ") , +)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "username"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: user :: select ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; username) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot select field nonexistent field $ field on model "User" , available fields are "id, username")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: id :: Select) } ; (@ selection_field_to_selection_param ; username) => { Into :: < $ crate :: prisma :: user :: SelectParam > :: into ($ crate :: prisma :: user :: username :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_select_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; username) => { "username" } ; }
	pub use _select_user as select;
	pub enum SelectParam {
		Id(id::Select),
		Username(username::Select),
	}
	impl SelectParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Username(data) => data.to_selection(),
			}
		}
	}
	#[macro_export]
	macro_rules ! _include_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } use super :: * ; pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Include { let mut selections = $ crate :: prisma :: user :: _outputs () ; selections . extend ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; Include (selections) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: user :: include ! (@ definitions ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Include (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: include :: IncludeType for Include { type Data = Data ; type ModelData = $ crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Include ({ let mut selections = $ crate :: prisma :: user :: _outputs () ; selections . extend ($ crate :: prisma :: user :: include ! (@ selections_to_include_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ())) ; selections }) } } ; (@ definitions ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] pub struct Data { pub id : i32 , pub username : String , $ (pub $ field : $ crate :: prisma :: user :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (username)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , username } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: user :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: user :: include ! (@ field_serde_name ; username) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: user :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: user :: include ! (@ field_serde_name ; username) => Ok (Field :: username) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut username = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: username => { if username . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; username))) ; } username = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; id))) ? ; let username = username . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: user :: include ! (@ field_serde_name ; username))) ? ; Ok (Data { id , username , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "username"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_include_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; username) => { "username" } ; }
	pub use _include_user as include;
	pub enum IncludeParam {
		Id(id::Include),
		Username(username::Include),
	}
	impl IncludeParam {
		pub fn to_selection(self) -> ::prisma_client_rust::Selection {
			match self {
				Self::Id(data) => data.to_selection(),
				Self::Username(data) => data.to_selection(),
			}
		}
	}
	#[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
	pub struct Data {
		#[serde(rename = "id")]
		pub id: i32,
		#[serde(rename = "username")]
		pub username: String,
	}
	impl Data {}
	#[derive(Clone)]
	pub enum WithParam {}
	impl Into<::prisma_client_rust::Selection> for WithParam {
		fn into(self) -> ::prisma_client_rust::Selection {
			match self {}
		}
	}
	#[derive(Clone)]
	pub enum SetParam {
		SetId(i32),
		IncrementId(i32),
		DecrementId(i32),
		MultiplyId(i32),
		DivideId(i32),
		SetUsername(String),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				SetParam::SetId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Int(value as i64),
				),
				SetParam::IncrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"increment".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DecrementId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"decrement".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::MultiplyId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"multiply".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::DivideId(value) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::Object(vec![(
						"divide".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				SetParam::SetUsername(value) => (
					"username".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum OrderByParam {
		Id(::prisma_client_rust::Direction),
		Username(::prisma_client_rust::Direction),
	}
	impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
		fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
			match self {
				Self::Id(direction) => (
					"id".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
				Self::Username(direction) => (
					"username".to_string(),
					::prisma_client_rust::PrismaValue::String(direction.to_string()),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum WhereParam {
		Not(Vec<WhereParam>),
		Or(Vec<WhereParam>),
		And(Vec<WhereParam>),
		IdEquals(i32),
		IdInVec(Vec<i32>),
		IdNotInVec(Vec<i32>),
		IdLt(i32),
		IdLte(i32),
		IdGt(i32),
		IdGte(i32),
		IdNot(i32),
		UsernameEquals(String),
		UsernameInVec(Vec<String>),
		UsernameNotInVec(Vec<String>),
		UsernameLt(String),
		UsernameLte(String),
		UsernameGt(String),
		UsernameGte(String),
		UsernameContains(String),
		UsernameStartsWith(String),
		UsernameEndsWith(String),
		UsernameNot(String),
	}
	impl Into<::prisma_client_rust::SerializedWhere> for WhereParam {
		fn into(self) -> ::prisma_client_rust::SerializedWhere {
			match self {
				Self::Not(value) => ::prisma_client_rust::SerializedWhere::new(
					"NOT",
					::prisma_client_rust::SerializedWhereValue::Object(
						value
							.into_iter()
							.map(Into::<::prisma_client_rust::SerializedWhere>::into)
							.map(Into::into)
							.collect(),
					),
				),
				Self::Or(value) => ::prisma_client_rust::SerializedWhere::new(
					"OR",
					::prisma_client_rust::SerializedWhereValue::List(
						value
							.into_iter()
							.map(Into::<::prisma_client_rust::SerializedWhere>::into)
							.map(Into::into)
							.map(|v| vec![v])
							.map(::prisma_client_rust::PrismaValue::Object)
							.collect(),
					),
				),
				Self::And(value) => ::prisma_client_rust::SerializedWhere::new(
					"AND",
					::prisma_client_rust::SerializedWhereValue::Object(
						value
							.into_iter()
							.map(Into::<::prisma_client_rust::SerializedWhere>::into)
							.map(Into::into)
							.collect(),
					),
				),
				Self::IdEquals(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdInVec(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"in".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::IdNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
								.collect(),
						),
					)]),
				),
				Self::IdLt(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdLte(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdGt(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdGte(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::IdNot(value) => ::prisma_client_rust::SerializedWhere::new(
					"id",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::Int(value as i64),
					)]),
				),
				Self::UsernameEquals(value) => ::prisma_client_rust::SerializedWhere::new(
					"username",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"equals".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::UsernameInVec(value) => ::prisma_client_rust::SerializedWhere::new(
					"username",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"in".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::String(v))
								.collect(),
						),
					)]),
				),
				Self::UsernameNotInVec(value) => ::prisma_client_rust::SerializedWhere::new(
					"username",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|v| ::prisma_client_rust::PrismaValue::String(v))
								.collect(),
						),
					)]),
				),
				Self::UsernameLt(value) => ::prisma_client_rust::SerializedWhere::new(
					"username",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::UsernameLte(value) => ::prisma_client_rust::SerializedWhere::new(
					"username",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"lte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::UsernameGt(value) => ::prisma_client_rust::SerializedWhere::new(
					"username",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gt".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::UsernameGte(value) => ::prisma_client_rust::SerializedWhere::new(
					"username",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"gte".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::UsernameContains(value) => ::prisma_client_rust::SerializedWhere::new(
					"username",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"contains".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::UsernameStartsWith(value) => ::prisma_client_rust::SerializedWhere::new(
					"username",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"startsWith".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::UsernameEndsWith(value) => ::prisma_client_rust::SerializedWhere::new(
					"username",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"endsWith".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
				Self::UsernameNot(value) => ::prisma_client_rust::SerializedWhere::new(
					"username",
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"not".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)]),
				),
			}
		}
	}
	#[derive(Clone)]
	pub enum UniqueWhereParam {
		UsernameEquals(String),
		IdEquals(i32),
	}
	impl From<UniqueWhereParam> for WhereParam {
		fn from(value: UniqueWhereParam) -> Self {
			match value {
				UniqueWhereParam::UsernameEquals(value) => Self::UsernameEquals(value),
				UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
			}
		}
	}
	impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
		fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
			match op {
				::prisma_client_rust::Operator::Not(value) => Self::Not(value),
				::prisma_client_rust::Operator::And(value) => Self::And(value),
				::prisma_client_rust::Operator::Or(value) => Self::Or(value),
			}
		}
	}
	pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<WithParam>;
	pub type ManyArgs =
		::prisma_client_rust::ManyArgs<WhereParam, WithParam, OrderByParam, UniqueWhereParam>;
	pub type Count<'a> =
		::prisma_client_rust::Count<'a, WhereParam, OrderByParam, UniqueWhereParam>;
	pub type Create<'a> = ::prisma_client_rust::Create<'a, SetParam, WithParam, Data>;
	pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, SetParam>;
	pub type FindUnique<'a> =
		::prisma_client_rust::FindUnique<'a, WhereParam, WithParam, SetParam, Data>;
	pub type FindMany<'a> = ::prisma_client_rust::FindMany<
		'a,
		WhereParam,
		WithParam,
		OrderByParam,
		UniqueWhereParam,
		SetParam,
		Data,
	>;
	pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<
		'a,
		WhereParam,
		WithParam,
		OrderByParam,
		UniqueWhereParam,
		Data,
	>;
	pub type Update<'a> = ::prisma_client_rust::Update<'a, WhereParam, WithParam, SetParam, Data>;
	pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, WhereParam, SetParam>;
	pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, WhereParam, SetParam, WithParam, Data>;
	pub type Delete<'a> = ::prisma_client_rust::Delete<'a, WhereParam, WithParam, Data>;
	pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, WhereParam>;
	pub struct Actions<'a> {
		pub client: &'a PrismaClient,
	}
	impl<'a> Actions<'a> {
		pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
			FindUnique::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where.into(),
			)
		}
		pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
			FindFirst::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where,
			)
		}
		pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
			FindMany::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where,
			)
		}
		pub fn create(self, username: String, mut _params: Vec<SetParam>) -> Create<'a> {
			_params.push(username::set(username));
			Create::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_params,
			)
		}
		pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
			Update::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where.into(),
				_params,
				vec![],
			)
		}
		pub fn update_many(
			self,
			_where: Vec<WhereParam>,
			_params: Vec<SetParam>,
		) -> UpdateMany<'a> {
			UpdateMany::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where,
				_params,
			)
		}
		pub fn upsert(
			self,
			_where: UniqueWhereParam,
			(username, mut _params): (String, Vec<SetParam>),
			_update: Vec<SetParam>,
		) -> Upsert<'a> {
			_params.push(username::set(username));
			Upsert::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where.into(),
				_params,
				_update,
			)
		}
		pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
			Delete::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where.into(),
				vec![],
			)
		}
		pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
			DeleteMany::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				_where.into(),
			)
		}
		pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
			Count::new(
				self.client._new_query_context(),
				::prisma_client_rust::QueryInfo::new("User", _outputs()),
				vec![],
			)
		}
	}
}
pub mod _prisma {
	pub struct PrismaClient {
		executor: ::prisma_client_rust::Executor,
		query_schema: ::std::sync::Arc<::prisma_client_rust::schema::QuerySchema>,
	}
	impl ::std::fmt::Debug for PrismaClient {
		fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
			f.debug_struct("PrismaClient").finish()
		}
	}
	impl PrismaClient {
		pub(super) fn _new_query_context(&self) -> ::prisma_client_rust::queries::QueryContext {
			::prisma_client_rust::queries::QueryContext::new(&self.executor, &self.query_schema)
		}
		pub(super) fn _new(
			executor: ::prisma_client_rust::Executor,
			query_schema: std::sync::Arc<::prisma_client_rust::schema::QuerySchema>,
		) -> Self {
			Self {
				executor,
				query_schema,
			}
		}
		pub fn _query_raw<T: serde::de::DeserializeOwned>(
			&self,
			query: ::prisma_client_rust::raw::Raw,
		) -> ::prisma_client_rust::QueryRaw<T> {
			::prisma_client_rust::QueryRaw::new(
				::prisma_client_rust::queries::QueryContext::new(
					&self.executor,
					&self.query_schema,
				),
				query,
				super::DATABASE_STR,
			)
		}
		pub fn _execute_raw(
			&self,
			query: ::prisma_client_rust::raw::Raw,
		) -> ::prisma_client_rust::ExecuteRaw {
			::prisma_client_rust::ExecuteRaw::new(
				::prisma_client_rust::queries::QueryContext::new(
					&self.executor,
					&self.query_schema,
				),
				query,
				super::DATABASE_STR,
			)
		}
		pub async fn _batch<T: ::prisma_client_rust::BatchContainer<Marker>, Marker>(
			&self,
			queries: T,
		) -> ::prisma_client_rust::queries::Result<T::ReturnType> {
			::prisma_client_rust::batch(queries, &self.executor, &self.query_schema).await
		}
		pub fn user(&self) -> super::user::Actions {
			super::user::Actions { client: &self }
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum SortOrder {
		#[serde(rename = "asc")]
		Asc,
		#[serde(rename = "desc")]
		Desc,
	}
	impl ToString for SortOrder {
		fn to_string(&self) -> String {
			match self {
				Self::Asc => "asc".to_string(),
				Self::Desc => "desc".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum TransactionIsolationLevel {
		#[serde(rename = "Serializable")]
		Serializable,
	}
	impl ToString for TransactionIsolationLevel {
		fn to_string(&self) -> String {
			match self {
				Self::Serializable => "Serializable".to_string(),
			}
		}
	}
	#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize)]
	pub enum UserScalarFieldEnum {
		#[serde(rename = "id")]
		Id,
		#[serde(rename = "username")]
		Username,
	}
	impl ToString for UserScalarFieldEnum {
		fn to_string(&self) -> String {
			match self {
				Self::Id => "id".to_string(),
				Self::Username => "username".to_string(),
			}
		}
	}
}
pub use _prisma::PrismaClient;
